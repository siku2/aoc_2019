---
title: "Day 24: Planet of Discord"
tags: ["cellular automata", "recursive space"]
mathjax: true
---

It was about time we finally got some cellular automata.
At first I was really surprised by the tiny input size but I still didn't see the second part coming.

I don't have a lot to say about the first part. It's cellular automata, call it game of life if you must, there's already enough information about it [out there](https://en.wikipedia.org/wiki/Cellular_automaton).

I do have a somewhat funny story to tell though (it's not really funny but please just bear with me).
Just because I felt like it I decided to store the cells in a one-dimensional array.
<br>
I'm sure you've already heard about this but just to make sure, there is a bijection (one-to-one mapping) from a two-dimensional array (given that the arrays are finite) to a one-dimensional array.
An element at (x, y) in two dimensions maps to the index (y * width + x) in one dimension.
<br>
*Adding width to the index moves to the same column on the next row.*
<br>
To go from one to two dimension it follow that $$y = \lfloor \frac{index} {width} \rfloor$$ and $$x= index \bmod width$$.

> Many languages use this "trick" for multidimensional arrays.
> They are laid out in [row- or column-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order) with some abstractions on top..
> In a way, even a one-dimensional integer array is a two-dimensional array of bits which is laid out in row-major order in memory.

"This is boring, where is the funny part?":
<br>
When counting the amount of bugs surrounding a position I used the naive implementation of just checking the four indices (i + 1), (i - 1), (i + width), (i - width).
<br>
I wouldn't blame you for not seeing the problem right away but imagine what happens if i is width - 1.
In that case (i + 1) would no longer map to (x + 1, y) but to (0, y + 1).
In the example:

```
....A
B..#.
#..##
..#..
#....
```

A would be considered adjacent to B.
That's not what we want so I had to add a check for this.
I guess the only lesson here is that you shouldn't forget to check your bounds, even when you're using Rust.

Apart from this hiccup nothing interesting happened while solving the first part so let's move on to the interesting part.

I always love it when puzzles come back in an alternate form so of course I was enjoyed the second part.
This is getting kind of long so I'll keep this brief.
All we really need to change is the way we count neighbours of a position.
When the position is on the border we need to consider the adjacent position one level above.
If the position is next to the center position we need to consider all positions on the border of the level below.

Each step we run collect the positions to be toggled for each level separately.
We also need to consider the level above the highest and below lowest layer.

This sounds a lot shorter than it actually is. There are a lot of cases to check.
The puzzle does sound a lot more complex than it actually is though.
I don't think that's a bad thing, it was a really creative puzzle and I thoroughly enjoyed it.

In other news, [Clippy](https://github.com/rust-lang/rust-clippy) started complaining about the "cognitive complexity" of my [trusty puzzle selection match statement](https://github.com/siku2/aoc_2019/blob/d23/src/puzzles/mod.rs).
I saw this as a great excuse to finally get rid of it.
Because I didn't want to rewrite every single module I decided to use the same logic more or less but with macros this time.
The macro I wrote takes identifiers (the module names of the days) imports them ("mod day_xx") and creates a function that builds a map from the puzzle identifier to the solver function.
The puzzle identifier is the composition of the day and part (ex: day 1, part 2 = (1, 2)).
This map is then used to get the solver function for a specific puzzle and the puzzle is solved by called the function with the input.

Instead of having 24 "mod day_xx" lines and another three lines for each day in the match statement now there's only a macro invocation with the module names:

```rust
day_modules![
    day_01, day_02, day_03, day_04, day_05, day_06, day_07, day_08, day_09, day_10, day_11, day_12,
    day_13, day_14, day_15, day_16, day_17, day_18, day_19, day_20, day_21, day_22, day_23, day_24
];
```

40 lines instead of 148 is a convincing argument I think. 
Sayonara big old match statement, you served me well!
